{"changed":true,"filter":false,"title":"physics.c","tooltip":"/src/physics.c","value":"#include \"physics.h\"\n\n#include <stdlib.h>\n\nbool collides(PhysicsBody *body1, PhysicsBody *body2)\n{\n\treturn body1->x == body2->x && body1->y == body2->y;\n}\n\nbool collides_obj(PhysicsBody *body, int otherX, int otherY)\n{\n\treturn body->x == otherX && body->y == otherY;\n}\n\nbool collides_accurate(PhysicsBody *body1, PhysicsBody *body2)\n{\n\treturn body1->xOffset == body2->xOffset && body1->yOffset == body2->yOffset && collides(body1, body2);\n}\n\nMovementResult move_ghost(PhysicsBody *body)\n{\n\t//default movement to not changing position\n\tMovementResult result = SameSquare;\n\n\tint xBefore = body->xOffset;\n\tint yBefore = body->yOffset;\n\n\tint xDir = 0;\n\tint yDir = 0;\n\n\tdir_xy(body->curDir, &xDir, &yDir);\n\n\t//we have double pixels so multiply by 2\n\tint BASE_VALUE = 75 * 2;\n\tint MULT_VALUE = 60;\n\n\t//our pixel value for the velocity\n\t//range between 1800 for v==40, to 4725 for v==105\n\tint velPixValue = (body->velocity / 100.0f) * BASE_VALUE;\n\n\tint divide = velPixValue / MULT_VALUE;\n\tint remain = velPixValue % MULT_VALUE;\n\n\t//add any new speed to current pixel position (only useful for velocity >= 80)\n\tbody->xOffset += divide * xDir;\n\tbody->yOffset += divide * yDir;\n\n\t//add any new carry to current carry (always useful except for velocity == 80)\n\tbody->xOffsetInternal += remain * xDir;\n\tbody->yOffsetInternal += remain * yDir;\n\n\t//add any new pixels we've introduced with our carry\n\t//this value will be non-zero if we have introduced enough carry\n\tint offX = body->xOffsetInternal / MULT_VALUE;\n\tint offY = body->yOffsetInternal / MULT_VALUE;\n\n\t//add to our pixel offset any new carry pixels\n\tbody->xOffset += offX;\n\tbody->yOffset += offY;\n\n\t//and subtract that carrys pixel from our offsetinternal\n\tbody->xOffsetInternal -= offX * MULT_VALUE;\n\tbody->yOffsetInternal -= offY * MULT_VALUE;\n\n\t// we should now have resolved all the values we need to\n\n\tint xNow = body->xOffset;\n\tint yNow = body->yOffset;\n\t//Now handle if we've moved over center, or into a new square\n\n\tbool overCenter = false;\n\tint overOffset = 0;\n\n\t//move over center square\n\tif ((xBefore < 0 && xNow >= 0) || (xBefore > 0 && xNow <= 0))\n\t{\n\t\toverCenter = true;\n\n\t\tresult = OverCenter;\n\n\t\t//transitioned over\n\t\toverOffset = abs(body->xOffset) * MULT_VALUE + abs(body->xOffsetInternal);\n\n\t\tbody->curDir = body->nextDir;\n\t}\n\telse if ((yBefore < 0 && yNow >= 0) || (yBefore > 0 && yNow <= 0))\n\t{\n\t\toverCenter = true;\n\n\t\tresult = OverCenter;\n\n\t\t//transitioned over\n\t\toverOffset = abs(body->xOffset) * MULT_VALUE + abs(body->xOffsetInternal);\n\n\t\tbody->curDir = body->nextDir;\n\t}\n\n\tif (overCenter)\n\t{\n\t\tdir_xy(body->curDir, &xDir, &yDir);\n\n\t\tbody->xOffset = overOffset / MULT_VALUE * xDir;\n\t\tbody->yOffset = overOffset / MULT_VALUE * yDir;\n\n\t\tbody->xOffsetInternal = (overOffset % MULT_VALUE) * xDir;\n\t\tbody->yOffsetInternal = (overOffset % MULT_VALUE) * yDir;\n\n\t\treturn result;\n\t}\n\n\t//check if we've gone onto a new square\n\t//int low = -8;\n\t//int high = 7;\n\tint low = -8;\n\tint high = 7;\n\tint offset = 15;\n\n\tif (body->xOffset < low)\n\t{\n\t\tbody->xOffset += offset;\n\t\tbody->x--;\n\n\t\tresult = NewSquare;\n\t}\n\telse if (body->xOffset > high)\n\t{\n\t\tbody->xOffset -= offset;\n\t\tbody->x++;\n\n\t\tresult = NewSquare;\n\t}\n\telse if (body->yOffset < low)\n\t{\n\t\tbody->yOffset += offset;\n\t\tbody->y--;\n\n\t\tresult = NewSquare;\n\t}\n\telse if (body->yOffset > high)\n\t{\n\t\tbody->yOffset -= offset;\n\t\tbody->y++;\n\n\t\tresult = NewSquare;\n\t}\n\n\treturn result;\n}\n\nbool move_pacman(PhysicsBody *body, bool canMoveCur, bool canMoveNext)\n{\n\t//default movement to not changing position\n\tMovementResult result = SameSquare;\n\n\tint xBefore = body->xOffset;\n\tint yBefore = body->yOffset;\n\n\tint xDir = 0;\n\tint yDir = 0;\n\n\tdir_xy(body->curDir, &xDir, &yDir);\n\n\t//we have double pixels so multiply by 2\n\tint BASE_VALUE = 75 * 2;\n\tint MULT_VALUE = 60;\n\n\t//our pixel value for the velocity\n\t//range between 1800 for v==40, to 4725 for v==105\n\tint velPixValue = (body->velocity / 100.0f) * BASE_VALUE;\n\n\tint divide = velPixValue / MULT_VALUE;\n\tint remain = velPixValue % MULT_VALUE;\n\n\t//add any new speed to current pixel position (only useful for velocity >= 80)\n\tbody->xOffset += divide * xDir;\n\tbody->yOffset += divide * yDir;\n\n\t//add any new carry to current carry (always useful except for velocity == 80)\n\tbody->xOffsetInternal += remain * xDir;\n\tbody->yOffsetInternal += remain * yDir;\n\n\t//add any new pixels we've introduced with our carry\n\t//this value will be non-zero if we have introduced enough carry\n\tint offX = body->xOffsetInternal / MULT_VALUE;\n\tint offY = body->yOffsetInternal / MULT_VALUE;\n\n\t//add to our pixel offset any new carry pixels\n\tbody->xOffset += offX;\n\tbody->yOffset += offY;\n\n\t//and subtract that carrys pixel from our offsetinternal\n\tbody->xOffsetInternal -= offX * MULT_VALUE;\n\tbody->yOffsetInternal -= offY * MULT_VALUE;\n\n\t// we should now have resolved all the values we need to\n\n\tint xNow = body->xOffset;\n\tint yNow = body->yOffset;\n\t//Now handle if we've moved over center, or into a new square\n\n\tbool overCenter = false;\n\tint overOffset = 0;\n\n\t//move over center square\n\tif ((xBefore < 0 && xNow >= 0) || (xBefore > 0 && xNow <= 0))\n\t{\n\t\toverCenter = true;\n\n\t\tresult = OverCenter;\n\n\t\t//transitioned over\n\t\toverOffset = abs(body->xOffset) * MULT_VALUE + abs(body->xOffsetInternal);\n\t}\n\telse if ((yBefore < 0 && yNow >= 0) || (yBefore > 0 && yNow <= 0))\n\t{\n\t\toverCenter = true;\n\n\t\tresult = OverCenter;\n\n\t\t//transitioned over\n\t\toverOffset = abs(body->xOffset) * MULT_VALUE + abs(body->xOffsetInternal);\n\t}\n\n\tif (overCenter)\n\t{\n\t\tDirection newDir;\n\n\t\tif (canMoveNext)\n\t\t{\n\t\t\tnewDir = body->nextDir;\n\t\t}\n\t\telse if (canMoveCur)\n\t\t{\n\t\t\tnewDir = body->curDir;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//they are stuck, so set everything to 0 then return\n\t\t\tbody->xOffset = 0;\n\t\t\tbody->yOffset = 0;\n\n\t\t\tbody->xOffsetInternal = 0;\n\t\t\tbody->yOffsetInternal = 0;\n\n\t\t\treturn result;\n\t\t}\n\n\t\tbody->curDir = newDir;\n\n\t\tdir_xy(newDir, &xDir, &yDir);\n\n\t\tbody->xOffset = overOffset / MULT_VALUE * xDir;\n\t\tbody->yOffset = overOffset / MULT_VALUE * yDir;\n\n\t\tbody->xOffsetInternal = (overOffset % MULT_VALUE) * xDir;\n\t\tbody->yOffsetInternal = (overOffset % MULT_VALUE) * yDir;\n\n\t\treturn result;\n\t}\n\n\t//check if we've gone onto a new square\n\t//int low = -8;\n\t//int high = 7;\n\tint low = -8;\n\tint high = 7;\n\tint offset = 15;\n\n\tif (body->xOffset < low)\n\t{\n\t\tbody->xOffset += offset;\n\t\tbody->x--;\n\n\t\tresult = NewSquare;\n\t}\n\telse if (body->xOffset > high)\n\t{\n\t\tbody->xOffset -= offset;\n\t\tbody->x++;\n\n\t\tresult = NewSquare;\n\t}\n\telse if (body->yOffset < low)\n\t{\n\t\tbody->yOffset += offset;\n\t\tbody->y--;\n\n\t\tresult = NewSquare;\n\t}\n\telse if (body->yOffset > high)\n\t{\n\t\tbody->yOffset -= offset;\n\t\tbody->y++;\n\n\t\tresult = NewSquare;\n\t}\n\n\treturn result;\n}\n\n// Note on center/ horo/ vert functions:\n// This pacman game uses 2 pixels for every pixel in the original game.\n// This means being in the \"center\" of a specific axis actually means either of 2 pixel locations !! 핵심\n// These functions deal with that\n\nbool on_center(PhysicsBody *body)\n{\n\treturn on_horo(body) && on_vert(body);\n}\n\nbool on_horo(PhysicsBody *body)\n{\n\treturn body->yOffset == 0;// || body->yOffset == 1;\n}\n\nbool on_vert(PhysicsBody *body)\n{\n\treturn body->xOffset == 0;// || body->xOffset == 1;\n}\n","undoManager":{"mark":-2,"position":7,"stack":[[{"start":{"row":301,"column":97},"end":{"row":301,"column":98},"action":"insert","lines":[" "],"id":2}],[{"start":{"row":301,"column":98},"end":{"row":301,"column":99},"action":"insert","lines":["!"],"id":3}],[{"start":{"row":301,"column":99},"end":{"row":301,"column":100},"action":"insert","lines":["!"],"id":4}],[{"start":{"row":301,"column":100},"end":{"row":301,"column":101},"action":"insert","lines":[" "],"id":5}],[{"start":{"row":301,"column":101},"end":{"row":301,"column":102},"action":"insert","lines":["핵"],"id":10}],[{"start":{"row":301,"column":102},"end":{"row":301,"column":103},"action":"insert","lines":["t"],"id":83}],[{"start":{"row":301,"column":102},"end":{"row":301,"column":103},"action":"remove","lines":["t"],"id":84}],[{"start":{"row":301,"column":102},"end":{"row":301,"column":103},"action":"insert","lines":["심"],"id":88}]]},"ace":{"folds":[],"scrolltop":3949,"scrollleft":0,"selection":{"start":{"row":300,"column":71},"end":{"row":300,"column":71},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0},"timestamp":1517549637093}