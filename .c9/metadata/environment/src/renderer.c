{"changed":true,"filter":false,"title":"renderer.c","tooltip":"/src/renderer.c","value":"#include \"renderer.h\"\n\n#include <SDL/SDL.h>\n#include <SDL/SDL_image.h>\n\n#include \"animation.h\"\n#include \"imageloader.h\"\n#include \"text.h\"\n#include \"window.h\"\n#include \"game.h\"\n\n//draws an image at a board coordinate\nvoid draw_image_coord(SDL_Surface *surface, int x, int y);\nvoid draw_image_coord_offset(SDL_Surface *surface, int x, int y, int xOffset, int yOffset);\n\n//Offset the board is off from the top of the screen\n//Needed because some items are stored in board (x,y) coords and need to be rendered at an offset\n#define Y_OFFSET 3\nstatic int offset = 3 * 16;\n\nvoid draw_image_coord(SDL_Surface *surface, int x, int y)\n{\n\tdraw_image_coord_offset(surface, x, y, 0, 0);\n}\n\nvoid draw_image_coord_offset(SDL_Surface *surface, int x, int y, int xOffset, int yOffset)\n{\n\tint pixPerTile = 16;\n\tapply_surface(pixPerTile * x + xOffset, pixPerTile * y + yOffset, surface);\n}\n\n//\n//\n// Vanity screen rendering\n//\n//\n\nvoid draw_vanity_ghostline(GhostDisplayRow *row, int y, bool drawDescription, bool drawName)\n{\n\tdraw_image_coord(ghost_image(row->type, Right, 0), 4, y);\n\n\tif (drawDescription)\n\t{\n\t\tset_text_color(row->color);\n\t\tdraw_text_coord(get_screen(), row->description, 7, y);\n\t}\n\n\tif (drawName)\n\t{\n\t\tdraw_text_coord(get_screen(), row->name, 18, y);\n\t}\n}\n\nvoid draw_vanity_charnickname(void)\n{\n\tset_text_color(WhiteText);\n\tdraw_text_coord(get_screen(), \"CHARACTER / NICKNAME\", 7, 5);\n}\n\nvoid draw_vanity_corporate_info(void)\n{\n\tset_text_color(PinkText);\n\tdraw_text_coord(get_screen(), \"@      MIDWAY MFG.CO.\", 4, 31);\n\tdraw_numtext_coord(get_screen(), \"  1980\", 4, 31);\n}\n\nvoid draw_vanity_pellet_info(bool flashing)\n{\n\t//TODO: use this properly\n\tif (flashing) return;\n\n\tset_text_color(WhiteText);\n\n\tdraw_image_coord(small_pellet_image(), 10, 24);\n\tdraw_numtext_coord(get_screen(), \"10\", 12, 24);\n\tdraw_image_coord(pts_white_image(), 15, 24);\n\n\tdraw_image_coord(large_pellet_image(), 10, 26);\n\tdraw_numtext_coord(get_screen(), \"50\", 12, 26);\n\tdraw_image_coord(pts_white_image(), 15, 26);\n}\n\nvoid draw_vanity_animation(int dt)\n{\n\t//TODO do this later\n\tif (dt)\n\t{\n\n\t}\n}\n\n//\n//\n// Instructions screen renderering\n//\n//\n\nvoid draw_instrc_info(void)\n{\n\tset_text_color(OrangeText);\n\tdraw_text_coord(get_screen(), \"PUSH START BUTTON\", 6, 16);\n\n\tset_text_color(CyanText);\n\tdraw_text_coord(get_screen(), \"  PLAYER ONLY\", 8, 20);\n\tdraw_numtext_coord(get_screen(), \"1\", 8, 20);\n\n\tset_text_color(PeachText);\n\tdraw_text_coord(get_screen(), \"BONUS PAC-MAN FOR\", 1, 24);\n\tdraw_numtext_coord(get_screen(), \"                  10000\", 1, 24);\n\tdraw_image_coord(pts_peach_image(), 25, 24);\n}\n\nvoid draw_instrc_corporate_info(void)\n{\n\tset_text_color(PinkText);\n\tdraw_text_coord(get_screen(), \"@      MIDWAY MFG.CO.\", 4, 28);\n\tdraw_numtext_coord(get_screen(), \"  1980\", 4, 28);\n}\n\n//\n//\n// Common menu rendering\n//\n//\n\nvoid draw_common_oneup(bool flashing, int score)\n{\n\tset_text_color(WhiteText);\n\tdraw_numtext_coord(get_screen(), \"1\", 3, 0);\n\tdraw_text_coord(get_screen(), \"UP\", 4, 0);\n\n\tif (flashing && animation_get_frame(265, 2)) return;\n\n\tchar scoreStr[256];\n\tsprintf(scoreStr, \"%01i\", score);\n\tdraw_text_coord(get_screen(), scoreStr, 6 - int_length(score), 1);\n}\n\nvoid draw_common_twoup(bool flashing, int score)\n{\n\tset_text_color(WhiteText);\n\tdraw_numtext_coord(get_screen(), \"2\", 22, 0);\n\tdraw_text_coord(get_screen(), \"UP\", 23, 0);\n\n\tif (flashing && animation_get_frame(265, 2)) return;\n\n\tchar scoreStr[256];\n\tsprintf(scoreStr, \"%01i\", score);\n\tdraw_text_coord(get_screen(), scoreStr, 6 - int_length(score), 1);\n}\n\nvoid draw_common_highscore(int highscore)\n{\n\tset_text_color(WhiteText);\n\tdraw_text_coord(get_screen(), \"HIGH SCORE\", 9, 0);\n\n\t//game doesn't render highscore if it is 0 for some reason. Emulate this behaviour\n\tif (highscore == 0) return;\n\n\tchar scoreStr[256];\n\tsprintf(scoreStr, \"%01i\", highscore);\n\tdraw_text_coord(get_screen(), scoreStr, 16 - int_length(highscore), 1);\n}\n\nvoid draw_credits(int numCredits)\n{\n\tif (numCredits < 0)\n\t{\n\t\tprintf(\"negative number credits: %d\\naborting\\b\", numCredits);\n\t\texit(1);\n\t}\n\n\tchar scoreStr[256];\n\tsprintf(scoreStr, \"   %i\", numCredits);\n\n\t//draw credit + number of credits at the appropriate place\n\tset_text_color(WhiteText);\n\tdraw_text_coord(get_screen(), \"CREDIT\", 2, 35);\n\n\tdraw_numtext_coord(get_screen(), scoreStr, 8 - int_length(numCredits), 35);\n}\n\n//\n// Game-only word rendering\n//\n\nvoid draw_game_playerone_start(void)\n{\n\tset_text_color(CyanText);\n\tdraw_text_coord(get_screen(), \"PLAYER ONE\", 9, 14);\n}\n\nvoid draw_game_playertwo_start(void)\n{\n\n}\n\nvoid draw_game_ready(void)\n{\n\tset_text_color(YellowText);\n\tdraw_text_coord(get_screen(), \"READY!\", 11, 20);\n}\n\nvoid draw_game_gameover(void)\n{\n\tset_text_color(RedText);\n\tdraw_text_coord(get_screen(), \"GAME  OVER\", 9, 20);\n}\n\n//\n//\n// Fruit renderering\n//\n//\n\nvoid draw_fruit_indicators(int currentLevel)\n{\n\tif (currentLevel < 1)\n\t{\n\t\tprintf(\"invalid level number for drawing fruit: %d\\naborting\\n\", currentLevel);\n\t\texit(1);\n\t}\n\n\tint x = 26 * 16;\n\tint y = 34 * 16;\n\n\tint index = currentLevel > 7 ? 7 : currentLevel;\n\n\tfor (int i = index; i > 0; i--)\n\t{\n\t\tFruit fruit = fruit_for_level(currentLevel - (index - i));\n\t\tSDL_Surface *image = get_fruit_image(fruit);\n\n\t\tapply_surface(x - i * 16 * 2, y, image);\n\t}\n}\n\n//Draws the fruit in the middle of the level.\nvoid draw_fruit_game(int currentLevel)\n{\n\tFruit fruit = fruit_for_level(currentLevel);\n\tSDL_Surface *image = get_fruit_image(fruit);\n\n\t//TODO: maybe this offset isn't the same for all fruit. Investigate\n\tdraw_image_coord_offset(image, 13, 19, 0, 8);\n}\n\n//\n//\n// Pellet renderering\n//\n//\n\nvoid draw_pellet_small(Pellet *p)\n{\n\tdraw_image_coord(p->image, p->x, p->y);\n}\n\nvoid draw_pellet_power(Pellet *p, bool flashing)\n{\n\t//do this properly\n\tif (flashing) return;\n\n\tdraw_image_coord(p->image, p->x, p->y);\n}\n\nvoid draw_small_pellets(PelletHolder *ph)\n{\n\tfor (int i = 0; i < NUM_PELLETS; i++)\n\t{\n\t\tPellet p = ph->pellets[i];\n\n\t\tif (p.type != SmallPellet) continue;\n\t\tif (p.eaten) continue;\n\n\t\tapply_surface(p.x * 16, offset + p.y * 16, p.image);\n\t}\n}\n\nvoid draw_large_pellets(PelletHolder *ph, bool flashing)\n{\n\t//actual tick rate is 10 * (1 / 60), or 10 frames\n\t//this comes out to 166.666 ms\n\t// 프레임조정\n\tint frame = animation_get_frame(167, 2);\n\n\tfor (int i = 0; i < NUM_PELLETS; i++)\n\t{\n\t\tPellet p = ph->pellets[i];\n\n\t\tif (p.type != LargePellet) continue;\n\t\tif (p.eaten) continue;\n\t\tif (flashing && frame == 1) continue;\n\n\t\tapply_surface(p.x * 16, offset + p.y * 16, p.image);\n\t}\n}\n\n//\n//\n// Pacman renderering\n//\n//\n\nvoid draw_pacman(Pacman *pacman)\n{\n\tint frame;\n\n\tDirection aniDir;\n\n\tif (pacman->movementType == Stuck)\n\t{\n\t\t//if left/ down, he needs full open frame\n\t\t//if up/ right, he uses semi-open frame\n\t\taniDir = pacman->lastAttemptedMoveDirection;\n\t\tif (aniDir == Left || aniDir == Down)\n\t\t{\n\t\t\tframe = 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tframe = 1;\n\t\t}\n\t}\n\telse\n\t{\n\t\taniDir = pacman->body.curDir;\n\t\tframe = animation_get_frame(50, 4);\n\t}\n\n\tint xOffset = pacman->body.xOffset - 4;\n\tint yOffset = offset + pacman->body.yOffset - 4;\n\n\tdraw_image_coord_offset(pacman_ani_image(aniDir, frame), pacman->body.x, pacman->body.y, xOffset, yOffset);\n}\n\nvoid draw_pacman_static(Pacman *pacman)\n{\n\tint xOffset = pacman->body.xOffset - 4;\n\tint yOffset = offset + pacman->body.yOffset - 6;\n\n\tdraw_image_coord_offset(pacman_image(), pacman->body.x, pacman->body.y, xOffset, yOffset);\n}\n\nvoid draw_pacman_death(Pacman *pacman, unsigned int dt)\n{\n\t//hangs on first image for 200ms\n\t//cycles through rest of images at constant rate\n\t//hangs on \"plop\" image for a while\n\n\tunsigned int hang1 = 200;\n\tunsigned int perFrame = 140;\n\tunsigned int hang2 = 200;\n\n\tint numFrames = 11;\n\n\tSDL_Surface *image;\n\n\tif (dt < hang1)\n\t{\n\t\timage = pacman_death_image(0);\n\t}\n\telse if (dt < (hang1 + numFrames * perFrame))\n\t{\n\t\tint i = animation_get_frame_dt(dt - hang1, perFrame, numFrames);\n\n\t\timage = pacman_death_image(i);\n\t}\n\telse if (dt < (hang1 + numFrames * perFrame + hang2))\n\t{\n\t\t//draw last frame\n\t\timage = pacman_death_image(10);\n\t}\n\telse\n\t{\n\t\t//draw nothing\n\t\treturn;\n\t}\n\n\tint xOffset = pacman->body.xOffset - 4;\n\tint yOffset = offset + pacman->body.yOffset - 6;\n\n\tdraw_image_coord_offset(image, pacman->body.x, pacman->body.y, xOffset, yOffset);\n}\n\nvoid draw_pacman_lives(int numLives)\n{\n\tint x = 2 * 16;\n\tint y = 34 * 16;\n\n\tfor (int i = 0; i < numLives; i++)\n\t{\n\t\tapply_surface(x, y, pacman_life_image());\n\n\t\tx += 16 * 2;\n\t}\n}\n\n//\n// Ghost rendering\n//\n\nvoid draw_ghost(Ghost *ghost)\n{\n\tSDL_Surface *image = ghost_image(ghost->ghostType, ghost->body.curDir, 0);\n\n\tint x = ghost->body.x;\n\tint y = ghost->body.y + Y_OFFSET;\n\n\tint xOffset = ghost->body.xOffset - 6;\n\tint yOffset = ghost->body.yOffset - 6;\n\n\tdraw_image_coord_offset(image, x, y, xOffset, yOffset);\n}\n\n//\n// Points rendering\n//\n\nvoid draw_fruit_pts(GameFruit *gameFruit)\n{\n\tFruit f = gameFruit->fruit;\n\tSDL_Surface *image = get_fruit_score_image(f);\n\n\tdraw_image_coord(image, gameFruit->x, gameFruit->y + 3);\n}\n\n//\n//\n// Board rendering\n//\n//\n\nvoid draw_board(Board *board)\n{\n\tfor (int y = 0; y < BOARD_HEIGHT; y++)\n\t{\n\t\tfor (int x = 0; x < BOARD_LENGTH; x++)\n\t\t{\n\t\t\tapply_surface(x * 16, offset + y * 16, (board->boardSquares[x][y]).image);\n\t\t}\n\t}\n}\n\nvoid draw_board_flash(Board *board)\n{\n\tint animate = animation_get_frame(250, 2);\n\n\t//TODO: make this draw the different colored board instead of just not drawing\n\tif (animate) return;\n\n\tfor (int y = 0; y < BOARD_HEIGHT; y++)\n\t{\n\t\tfor (int x = 0; x < BOARD_LENGTH; x++)\n\t\t{\n\t\t\tapply_surface(x * 16, offset + y * 16, (board->boardSquares[x][y]).image);\n\t\t}\n\t}\n}\n","undoManager":{"mark":-2,"position":8,"stack":[[{"start":{"row":282,"column":31},"end":{"row":283,"column":0},"action":"insert","lines":["",""],"id":2},{"start":{"row":283,"column":0},"end":{"row":283,"column":1},"action":"insert","lines":["\t"]}],[{"start":{"row":283,"column":1},"end":{"row":283,"column":2},"action":"insert","lines":["/"],"id":3}],[{"start":{"row":283,"column":2},"end":{"row":283,"column":3},"action":"insert","lines":["/"],"id":4}],[{"start":{"row":283,"column":3},"end":{"row":283,"column":4},"action":"insert","lines":[" "],"id":5}],[{"start":{"row":283,"column":4},"end":{"row":283,"column":5},"action":"insert","lines":["프"],"id":12}],[{"start":{"row":283,"column":5},"end":{"row":283,"column":6},"action":"insert","lines":["레"],"id":15}],[{"start":{"row":283,"column":6},"end":{"row":283,"column":7},"action":"insert","lines":["임"],"id":17}],[{"start":{"row":283,"column":7},"end":{"row":283,"column":8},"action":"insert","lines":["조"],"id":21}],[{"start":{"row":283,"column":8},"end":{"row":283,"column":9},"action":"insert","lines":["정"],"id":24}]]},"ace":{"folds":[],"scrolltop":4125,"scrollleft":0,"selection":{"start":{"row":324,"column":5},"end":{"row":324,"column":5},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":560,"mode":"ace/mode/c_cpp"}},"timestamp":1517549262760}